
//: ### 访问控制
/*:
 访问控制可以限定其他源文件或模块中的代码对你的代码的访问级别。这个特性可以让我们隐藏代码的一些实现细节，并且可以为其他人可以访问和使用的代码提供接口  
 可以明确的给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数
 */

/*:
 1 不可以在某个实体中定义访问级别更低的实体
 2 如果不为代码中的实体显示指定访问级别，那么它们默认为 internal 级别
 3 通过修饰符 open，public，internal， filepart, private 来声明实体的访问级别
 */

/*:
 * open，public 开放访问和公开访问可以访问同一块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体
 * internal 内部访问可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体
 * fileprivate 文件私有访问限制实体之只能被所定义的文件内部访问
 * private 私有访问限制实体只能在所定义的作用域内使用
 */

/*:
 如果想为一个自定义类型指定访问级别，在定义类型时进行指定即可。新类型只能在它的访问级别限制范围内使用  
 一个类型的访问级别也会影响到类型成员（属性、方法、构造器、下标）的默认访问级别。如果将类型定义为私有或者文件私有级别，那么该类型的所有成员的默认访问级别也会变成私有或者文件私有级别。如果将类型指定为公开或者内部访问级别，那么该类型的所有成员的默认访问级别将是内部访问
 */

//: #### 元组类型
/*:
 元组的访问级别将由元组中访问级别最严格（低）的类型来决定。元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推断出的，而无法明确指定
 */

//: #### 函数类型
/*:
 函数的访问级别根据访问级别 最严格 的 参数类型 或 返回类型 的级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确的指定该函数的访问级别
 */

//: #### 枚举类型
/*:
 枚举成员的访问级别和该枚举类型相同，不能为枚举成员单独指定不同的访问级别  
 枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别
 */
public enum CompassPoint {
    case North
    case South
    case East
    case West
}

//: #### 嵌套类型
/*:
 在什么级别中定义嵌套类型，那么该嵌套类型就自动拥有该级别。
 */

//: #### 子类
/*:
 子类的访问级别不能高于父类的访问级别 
 可以通过重写为继承来的类成员提供更高的访问级别  
 可以在子类中，用子类成员去访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围内（在同一源文件中访问父类 private 级别的成员，在同一模块内访问父类 internal 级别的成员）
 */

//: #### 常量、变量、属性、下标
/*:
 常量、变量、属性不能拥有比它们的类型更高的访问级别  
 下标不能拥有比索引类型或返回类型更高的访问级别
 */

//: #### Getter 和 Setter
/*:
 Getter和Setter的访问级别和它们所属类型的访问级别相同  
 Setter的访问级别可以抵御对应的Getter的访问级别，这样就可以控制变量、属性或下标的读写权限。在 var 或者 subscript 关键字之前，可以通过 fileprivate(set) private(set) internal(set)为它们的写入权限指定更低的访问级别
 */

public struct TrackedString {
    public private(set) var numberOfEdits = 0 //在外部可以get，但是不能set
    public var value: String = "" {
        didSet {
            numberOfEdits += 1
        }
    }
    
    public init(){}
}


//: #### 构造器
/*:
 自定义构造器的访问级别可以低于或等于其所属类型的访问级别。但是必要构造器的访问级别必须和所属类型的访问级别相同  
 构造器参数的访问级别也不能低于构造器本身的访问级别
 */

//: #### 默认构造器
/*:
 默认构造器的访问级别与所属类型的访问级别相同，除非类型的访问级别是public。如果一个类型被指定为 public 级别，那么默认构造器的访问级别为 internal。
 */

//: #### 结构体默认的成员逐一构造器
/*:
 如果结构体中任意存储属性的访问级别为private，那么该结构体默认的成员逐一构造器的访问级别就是private
 */

//: #### 协议
/*:
 如果想为一个协议类型明确指定访问级别，在定义协议时指定即可。这将限制该协议只能在适当的访问级别范围内被采纳。协议中的每一个要求都具有和协议相同的访问级别。不能将协议中的要求设置为其他访问级别
 */

//: #### 协议继承
/*:
 如果定义一个继承自其他协议的新协议，那么新协议拥有的访问级别最高也只能和被继承协议的访问级别相同
 */

//: #### 协议一致性
/*:
 一个类型可以采纳比自身访问级别低的协议。  
 采纳了协议的类型的访问级别取它本身和所采纳协议两者间最低的访问级别。  
 如果采纳了协议，那么实现了协议的所有要求后，你必须确保这些实现的访问级别不能低于协议的访问级别
 */

//: #### 扩展
/*:
 可以在访问级别允许的情况下对类、结构体、枚举进行扩展。扩展成员具有和原始类型成员一致的访问级别
 也可以明确指定扩展的访问级别，从而给该扩展中的所有成员指定一个新的默认访问级别。这个新的默认访问级别仍然可以被单独指定的访问级别所覆盖
 */

//: #### 通过扩展添加协议一致性
/*:
 如果你通过扩展来采纳协议，那么就不能显式指定该扩展的访问级别了。协议拥有相应的访问级别，并会为该扩展中所有协议要求的实现提供默认的访问级别
 */

//: #### 泛型
/*:
 泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。
 */

//: #### 类型别名
/*:
 定义的任何类型别名都会被当作不同的类型，以便于进行访问控制。类型别名的访问级别不可高于其表示的类型的访问级别。
 */




























